#ifndef DITTOFII_H
#define DITTOFII_H

/* Store-related forward declarations */
struct Ditto_Expression;
typedef struct Ditto_Expression Ditto_Expression;
struct Ditto_ReadTransaction;
typedef struct Ditto_ReadTransaction Ditto_ReadTransaction;
struct Ditto_WriteTransaction;
typedef struct Ditto_WriteTransaction Ditto_WriteTransaction;
struct Ditto_QueryFilter;
typedef struct Ditto_QueryFilter Ditto_QueryFilter;
struct Ditto_CollectionNames;
typedef struct Ditto_CollectionNames Ditto_CollectionNames;


/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define SEND_RESULT_ACCEPTED 1

#define SEND_RESULT_WAIT_FOR_READY 2

/**
 * When receiving data from a Bluetooth LE peer, such as a characteristic
 * write, indicates what sort of data it is.
 */
enum BleDataType {
  /**
   * The data _should_ contain the remote peer's announce string.
   * Used during handshake.
   */
  BLE_DATA_TYPE_ANNOUNCE = 0,
  /**
   * Data message
   */
  BLE_DATA_TYPE_MESH_DATA = 1,
  /**
   * Control message
   */
  BLE_DATA_TYPE_CONTROL = 2,
};

/**
 * Generic enum used by crate and platforms to indicate a connection status
 */
enum ConnectState {
  CONNECT_STATE_DISCONNECTED,
  CONNECT_STATE_CONNECTED,
  CONNECT_STATE_CONNECTING,
  CONNECT_STATE_DISCONNECTING,
};

/**
 * Generic enum used by crate and platforms to indicate online-ness.
 *
 * In other words, is something active or not? Not everything will use the
 * transitional states.
 */
enum OnlineState {
  ONLINE_STATE_OFFLINE,
  ONLINE_STATE_ONLINE,
  ONLINE_STATE_GOING_ONLINE,
  ONLINE_STATE_GOING_OFFLINE,
};

/**
 * Query compilation result
 */
enum Ditto_QueryCompileResult {
  /**
   * Compilation was successful.
   */
  QUERY_COMPILE_RESULT_QUERY_COMPILE_SUCCESS = 0,
  /**
   * Invalid input. Can be wrong syntax, wrong result type, etc.
   */
  QUERY_COMPILE_RESULT_QUERY_COMPILE_INVALID_INPUT = 1,
  /**
   * Failure during compilation or transpilation.
   */
  QUERY_COMPILE_RESULT_QUERY_COMPILE_COMPILE_FAILED = 2,
};

/**
 * A code reported by platforms/transports to indicate specific health
 * conditions
 */
enum TransportCondition {
  /**
   * A default state. Only use this for transient conditions, e.g., we are
   * waiting for a platform to finish starting up. If everything is just
   * quiet, use `Ok`.
   */
  TRANSPORT_CONDITION_UNKNOWN,
  /**
   * No known problems.
   */
  TRANSPORT_CONDITION_OK,
  /**
   * Catch-all failure, particularly for unexpected/internal faults. If
   * possible, add a new case that the customer will be able to
   * interpret.
   */
  TRANSPORT_CONDITION_GENERIC_FAILURE,
  /**
   * We are not able to publish or discover with the mDNS daemon
   */
  TRANSPORT_CONDITION_MDNS_FAILURE,
  /**
   * We cannot bind to a port.
   */
  TRANSPORT_CONDITION_TCP_LISTEN_FAILURE,
  /**
   * No app permission to act as a BLE Central.
   */
  TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION,
  /**
   * No app permission to act as a BLE Peripheral.
   */
  TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION,
  /**
   * This Transport targets a particular peer and we can't reach them right
   * now.
   */
  TRANSPORT_CONDITION_CANNOT_ESTABLISH_CONNECTION,
  /**
   * The device has Bluetooth disabled at the OS level.
   */
  TRANSPORT_CONDITION_BLE_DISABLED,
  /**
   * The device has no Bluetooth hardware
   */
  TRANSPORT_CONDITION_NO_BLE_HARDWARE,
};

struct Arc_AwdlClientPlatformCallbacks;

struct Arc_AwdlServerPlatformCallbacks;

struct Arc_ClientPlatformCallbacks;

struct Arc_FfiAwdlClientPlatform;

struct Arc_FfiAwdlServerPlatform;

struct Arc_FfiClientPlatform;

struct Arc_FfiMdnsPlatform;

struct Arc_FfiServerPlatform;

struct Arc_MdnsPlatformCallbacks;

struct Arc_ServerPlatformCallbacks;

/**
 * Read transaction synchronous API.
 */
struct Ditto_ReadTransaction;

/**
 * Write transaction synchronous API.
 */
struct Ditto_WriteTransaction;

struct Ditto;

/**
 * Database document
 */
struct Ditto_Document;

struct UninitializedDitto;

/**
 * Represents an iterator over collection names
 *
 * When created by `collections` function, the first value of `name`
 * must be set to `NULL` and the `next` function must be used to iterate
 * over it. Once `next` returns 0, the iterator is complete and the
 * instance of this structure is deallocated.
 */
struct Ditto_CollectionNames {
  /**
   * \private
   */
  const void *iterator;
  /**
   * collection name
   */
  char *name;
};

/**
 * Compiled query expression
 */
typedef Ditto_Expression Ditto_CompiledQuery;

/**
 * Order Definition.
 */
struct Ditto_OrderDefinition {
  const Ditto_CompiledQuery *projection;
  bool desc;
};

/**
 * Query Filter synchronous API.
 */
struct Ditto_QueryFilter {
  /**
   * \private
   */
  const void *query_iter;
};

/**
 * The platform advises Rust that a peer has changed its current connection
 * status
 */
void awdl_client_connect_state_changed(struct Arc_FfiAwdlClientPlatform *platform,
                                       const char *announce,
                                       enum ConnectState state);

void awdl_client_platform_callbacks_free(struct Arc_AwdlClientPlatformCallbacks *mp);

struct Arc_AwdlClientPlatformCallbacks *awdl_client_platform_callbacks_new(void);

/**
 * The platform advises Rust that a peer has been identified. We know only its
 * announce string.
 */
void awdl_client_platform_peer_appeared(struct Arc_FfiAwdlClientPlatform *mp, const char *announce);

/**
 * The platform advises Rust that a peer has disappeared.
 */
void awdl_client_platform_peer_disappeared(struct Arc_FfiAwdlClientPlatform *mp,
                                           const char *announce);

void awdl_client_platform_register_request_connect(struct Arc_AwdlClientPlatformCallbacks *mp,
                                                   void *ctx,
                                                   void (*c_cb)(void *ctx, const char *announce));

void awdl_client_platform_register_request_disconnect(struct Arc_AwdlClientPlatformCallbacks *mp,
                                                      void *ctx,
                                                      void (*c_cb)(void *ctx, const char *announce));

void awdl_client_platform_register_send_data(struct Arc_AwdlClientPlatformCallbacks *mp,
                                             void *ctx,
                                             unsigned int (*c_cb)(void *ctx, const char *announce, const unsigned char *data, unsigned int data_len));

/**
 * Register a function that Rust can call to make the AWDL querier report Ditto
 * peers on an ongoing basis. This may be interrupted by events such as the
 * user backgrounding/foregrounding their app. Currently, this is not exposed
 * to Rust.
 */
void awdl_client_platform_register_start_searching(struct Arc_AwdlClientPlatformCallbacks *mp,
                                                   void *ctx,
                                                   void (*c_cb)(void *ctx, const char *announce, const char *app_name));

/**
 * Register a function that Rust can call to make the AWDL querier stop looking
 * for Ditto peers.
 */
void awdl_client_platform_register_stop_searching(struct Arc_AwdlClientPlatformCallbacks *mp,
                                                  void *ctx,
                                                  void (*c_cb)(void *ctx));

/**
 * The platform advises Rust that a given peer is now clear to queue up a new
 * message whenever one is ready to go
 */
void awdl_client_ready_to_send(struct Arc_FfiAwdlClientPlatform *platform, const char *announce);

/**
 * The platform advises Rust that a complete message has been received from a
 * remote peer
 */
void awdl_client_received_data(struct Arc_FfiAwdlClientPlatform *platform,
                               const char *announce,
                               const unsigned char *data,
                               unsigned int data_len);

/**
 * The platform advises Rust that searching status changed
 */
void awdl_client_scanning_state_changed(struct Arc_FfiAwdlClientPlatform *platform,
                                        enum OnlineState state,
                                        enum TransportCondition result);

/**
 * The platform advises Rust that advertising status changed
 */
void awdl_server_advertising_state_changed(struct Arc_FfiAwdlServerPlatform *platform,
                                           enum OnlineState state,
                                           enum TransportCondition result);

/**
 * The platform advises Rust that a peer has changed its current connection
 * status
 */
void awdl_server_connect_state_changed(struct Arc_FfiAwdlServerPlatform *platform,
                                       int64_t platform_id,
                                       enum ConnectState state);

void awdl_server_platform_callbacks_free(struct Arc_AwdlServerPlatformCallbacks *mp);

struct Arc_AwdlServerPlatformCallbacks *awdl_server_platform_callbacks_new(void);

/**
 * The platform advises Rust that a peer has been identified. We know only its
 * announce string.
 */
void awdl_server_platform_peer_appeared(struct Arc_FfiAwdlServerPlatform *mp,
                                        int64_t platform_id,
                                        const char *announce);

/**
 * The platform advises Rust that a peer has disappeared.
 */
void awdl_server_platform_peer_disappeared(struct Arc_FfiAwdlServerPlatform *mp,
                                           int64_t platform_id);

void awdl_server_platform_register_request_disconnect(struct Arc_AwdlServerPlatformCallbacks *mp,
                                                      void *ctx,
                                                      void (*c_cb)(void *ctx, long long platform_id));

void awdl_server_platform_register_send_data(struct Arc_AwdlServerPlatformCallbacks *mp,
                                             void *ctx,
                                             unsigned int (*c_cb)(void *ctx, long long platform_id, const unsigned char *data, unsigned int data_len));

/**
 * Register a function that Rust can call to start an AWDL responder on the
 * current device. It should include the service name string (in practice, the
 * announce string) and the TCP port that the Ditto TCP service is listening
 * on.
 */
void awdl_server_platform_register_start_advertising(struct Arc_AwdlServerPlatformCallbacks *mp,
                                                     void *ctx,
                                                     void (*c_cb)(void *ctx, const char *announce, const char *app_name));

/**
 * Register a function that Rust can call to stop the AWDL responder on the
 * current device.
 */
void awdl_server_platform_register_stop_advertising(struct Arc_AwdlServerPlatformCallbacks *mp,
                                                    void *ctx,
                                                    void (*c_cb)(void *ctx));

/**
 * The platform advises Rust that a given peer is now clear to queue up a new
 * message whenever one is ready to go
 */
void awdl_server_ready_to_send(struct Arc_FfiAwdlServerPlatform *platform, int64_t platform_id);

/**
 * The platform advises Rust that a complete message has been received from a
 * remote peer
 */
void awdl_server_received_data(struct Arc_FfiAwdlServerPlatform *platform,
                               int64_t platform_id,
                               const unsigned char *data,
                               unsigned int data_len);

void ble_advertisement_heard(struct Arc_FfiClientPlatform *platform,
                             const unsigned char *peripheral_uuid,
                             const unsigned char *local_name,
                             int local_name_len);

void ble_advertising_state_changed(struct Arc_FfiServerPlatform *platform,
                                   enum OnlineState state,
                                   enum TransportCondition result);

void ble_central_mtu_updated(struct Arc_FfiServerPlatform *platform,
                             const unsigned char *uuid,
                             unsigned int mtu);

void ble_central_ready_to_send(struct Arc_FfiServerPlatform *platform, const unsigned char *uuid);

/**
 * Free the platform's copy of an `Arc<ClientPlatformCallbacks>`
 */
void ble_client_platform_callbacks_free(struct Arc_ClientPlatformCallbacks *cb);

/**
 * Create a new instance of `Arc<ClientPlatformCallbacks>` owned by the
 * platform
 */
struct Arc_ClientPlatformCallbacks *ble_client_platform_callbacks_new(void);

void ble_connection_state_changed(struct Arc_FfiClientPlatform *platform,
                                  const unsigned char *peripheral_uuid,
                                  enum ConnectState state);

void ble_peripheral_mtu_updated(struct Arc_FfiClientPlatform *platform,
                                const unsigned char *uuid,
                                unsigned int mtu);

void ble_peripheral_ready_to_send(struct Arc_FfiClientPlatform *platform,
                                  const unsigned char *uuid);

void ble_received_from_central(struct Arc_FfiServerPlatform *platform,
                               const unsigned char *central_uuid,
                               enum BleDataType data_type,
                               const unsigned char *data,
                               int data_len);

void ble_received_from_peripheral(struct Arc_FfiClientPlatform *platform,
                                  const unsigned char *peripheral_uuid,
                                  enum BleDataType data_type,
                                  const unsigned char *data,
                                  int data_len);

void ble_register_advertising_state(struct Arc_ServerPlatformCallbacks *callbacks,
                                    void *ctx,
                                    enum OnlineState (*c_cb)(void *ctx));

void ble_register_connect_peripheral(struct Arc_ClientPlatformCallbacks *callbacks,
                                     void *ctx,
                                     void (*c_cb)(void *ctx, const unsigned char *peripheral_uuid));

void ble_register_disconnect_peripheral(struct Arc_ClientPlatformCallbacks *callbacks,
                                        void *ctx,
                                        void (*c_cb)(void *ctx, const unsigned char *peripheral_uuid));

void ble_register_notify_to_central(struct Arc_ServerPlatformCallbacks *callbacks,
                                    void *ctx,
                                    unsigned int (*c_cb)(void *ctx, enum BleDataType send_type, const unsigned char *central_uuid, const unsigned char *data, int data_len));

void ble_register_scanning_state(struct Arc_ClientPlatformCallbacks *callbacks,
                                 void *ctx,
                                 enum OnlineState (*c_cb)(void *ctx));

void ble_register_start_advertising(struct Arc_ServerPlatformCallbacks *callbacks,
                                    void *ctx,
                                    void (*c_cb)(void *ctx, const unsigned char *service_uuid, const unsigned char *local_name, int local_name_len));

void ble_register_start_scanning(struct Arc_ClientPlatformCallbacks *callbacks,
                                 void *ctx,
                                 void (*c_cb)(void *ctx, const unsigned char *service_uuid, const unsigned char *announce, int announce_len));

void ble_register_stop_advertising(struct Arc_ServerPlatformCallbacks *callbacks,
                                   void *ctx,
                                   void (*c_cb)(void *ctx));

void ble_register_stop_scanning(struct Arc_ClientPlatformCallbacks *callbacks,
                                void *ctx,
                                void (*c_cb)(void *ctx));

void ble_register_write_to_peripheral(struct Arc_ClientPlatformCallbacks *callbacks,
                                      void *ctx,
                                      unsigned int (*c_cb)(void *ctx, enum BleDataType send_type, const unsigned char *peripheral_uuid, const unsigned char *data, int data_len));

void ble_scanning_state_changed(struct Arc_FfiClientPlatform *platform,
                                enum OnlineState state,
                                enum TransportCondition result);

/**
 * Free the platform's copy of an `Arc<ServerPlatformCallbacks>`
 */
void ble_server_platform_callbacks_free(struct Arc_ServerPlatformCallbacks *cb);

/**
 * Create a new instance of `Arc<ServerPlatformCallbacks>` owned by the
 * platform
 */
struct Arc_ServerPlatformCallbacks *ble_server_platform_callbacks_new(void);

void ble_subscription_from_central(struct Arc_FfiServerPlatform *platform,
                                   const unsigned char *central_uuid,
                                   enum ConnectState subscribed);

long long ditto_add_awdl_client_transport(struct Ditto *ditto_raw);

long long ditto_add_awdl_server_transport(struct Ditto *ditto_raw);

long long ditto_add_ble_client_transport(struct Ditto *ditto_raw);

long long ditto_add_ble_server_transport(struct Ditto *ditto_raw);

long long ditto_add_mdns_transport(struct Ditto *ditto_raw);

/**
 * Add a subscription
 */
void ditto_add_subscription(struct Ditto *ditto_raw, const char *collection, const char *query);

/**
 * Add a WebSocket connect transport.
 * The return value is a transport id. In case of error due to an invalid
 * 'addr' (not valid UTF-8) the return value is -1.
 */
long long ditto_add_ws_connect_transport(struct Ditto *ditto_raw, const char *addr);

/**
 * Add a WebSocket listen transport.
 */
long long ditto_add_ws_listen_transport(struct Ditto *ditto_raw, const char *bind);

/**
 * Add a WebSocket listen transport.
 */
long long ditto_add_ws_listen_transport_with_advertiser(struct Ditto *ditto_raw, const char *bind);

void ditto_ble_client_platform_free(struct Arc_FfiClientPlatform *platform);

void ditto_ble_server_platform_free(struct Arc_FfiServerPlatform *platform);

/**
 * Releases a byte array value returned by DittoStore.
 *
 * DittoStore manages its own memory allocations and it is not safe to release such values with
 * C's `free()`. That's why the structures it returns provide their own associated `free`
 * function.
 *
 * It should be used for values returned by functions like `ditto_document_cbor`.
 */
void ditto_c_bytes_free(const unsigned char *bytes_ptr, uintptr_t len);

/**
 * Releases `char *` value returned by DittoStore.
 *
 * DittoStore manages its own memory allocations and it is not safe to release
 * such values with C's `free()`. That's why the structures it returns provide
 * their own associated `free` function and this is one we need this function
 * for `char *`.
 *
 * It should be used for values returned by functions like
 * Ditto_QueryFilter::next.
 */
void ditto_c_string_free(char *string);

/**
 * Empty error callback
 * (useful for passing to `err_cb` functions to ignore errors; use with
 * caution)
 */
void ditto_callback_err_nop(int _code, const char *_err, void *_data);

/**
 * Empty callback (useful for passing to `free` functions)
 */
void ditto_callback_nop(const void *_data);

/**
 * Clear the store of an existing cached site ID, if one exists.
 */
int ditto_clear_site_id(struct Ditto *ditto_raw);

/**
 * Clear the condition callback stored by the Ditto object's status property.
 * This ensures that if the platform-level object that was provided as the
 * context parameter for the condition object is freed before the Ditto object
 * is freed then the condition callback won't lead to a crash where the
 * platform-provided object tries to be accessed when it has already been
 * freed.
 */
void ditto_clear_status_condition_callback(struct Ditto *ditto_raw);

int ditto_collection(struct Ditto *ditto_raw, const char *name);

int ditto_collection_evict(struct Ditto *ditto_raw,
                           const char *coll_name,
                           const struct Ditto_WriteTransaction *transaction,
                           const char *id);

int ditto_collection_get(struct Ditto *ditto_raw,
                         const char *coll_name,
                         const char *id,
                         const struct Ditto_ReadTransaction *transaction,
                         const struct Ditto_Document **document);

int ditto_collection_insert(struct Ditto *ditto_raw,
                            const char *coll_name,
                            const struct Ditto_WriteTransaction *transaction,
                            struct Ditto_Document *document,
                            const char **id);

int ditto_collection_remove(struct Ditto *ditto_raw,
                            const char *coll_name,
                            const struct Ditto_WriteTransaction *transaction,
                            const char *id);

int ditto_collection_update(struct Ditto *ditto_raw,
                            const char *coll_name,
                            const struct Ditto_WriteTransaction *transaction,
                            struct Ditto_Document *document);

int ditto_collections(struct Ditto *ditto_raw, struct Ditto_CollectionNames **collections);

void ditto_collections_free(struct Ditto_CollectionNames *collections);

int ditto_collections_next(struct Ditto_CollectionNames *collections);

/**
 * Document's CBOR
 */
const unsigned char *ditto_document_cbor(const struct Ditto_Document *document,
                                         uintptr_t *out_cbor_len);

/**
 * Releases the document
 */
void ditto_document_free(struct Ditto_Document *document);

/**
 * Gets the JSON value at the pointer
 *
 * Returns NULL if none found
 *
 * The resulting string has to be released with `::ditto_c_string_free`
 */
char *ditto_document_get(const struct Ditto_Document *document, const char *pointer);

/**
 * Gets the JSON value at the pointer
 *
 * Returns NULL if none found
 *
 * The resulting string has to be released with `::ditto_c_string_free`
 */
const unsigned char *ditto_document_get_cbor(const struct Ditto_Document *document,
                                             const char *pointer,
                                             uintptr_t *out_cbor_len);

/**
 * Document's rendered ID
 *
 * This is more efficient than getting document's JSON and looking up "_id"
 *
 * If there's no ID, a NULL will be returned.
 *
 * The resulting string has to be released with `::ditto_c_string_free`
 */
char *ditto_document_id(const struct Ditto_Document *document);

int ditto_document_increment_counter(struct Ditto_Document *document,
                                     const char *pointer,
                                     double amount);

/**
 * Inserts JSON value `expr` at a JSON pointer `pointer`
 *
 * Returns following error codes:
 *
 * * `0` -- no error
 * * `1` -- invalid `expr` JSON
 * * `2` -- insertion error
 *
 * In case of a non-zero return value, error message can be retrieved using
 * `::ditto_error_message` function.
 */
int ditto_document_insert(struct Ditto_Document *document, const char *pointer, const char *expr);

int ditto_document_insert_cbor(struct Ditto_Document *document,
                               const char *pointer,
                               const unsigned char *cbor_ptr,
                               uintptr_t cbor_len,
                               bool create_path);

int ditto_document_insert_cbor_with_timestamp(struct Ditto_Document *document,
                                              const char *pointer,
                                              const unsigned char *cbor_ptr,
                                              uintptr_t cbor_len,
                                              bool create_path,
                                              unsigned int timestamp);

/**
 * Document's rendered JSON
 *
 * The resulting string has to be released with `::ditto_c_string_free`
 */
char *ditto_document_json(const struct Ditto_Document *document);

/**
 * Creates a new document from a JSON
 *
 * It will allocate a new document and set `document` pointer to it. It will
 * later need to be released with `::ditto_document_free`.
 *
 * The input `json` must be a valid JSON object.
 *
 * Return codes:
 *
 * * `0` -- success
 * * `1` -- invalid JSON
 * * `2` -- JSON is not an object
 */
int ditto_document_new(const char *json, const struct Ditto_Document **document);

/**
 * Creates a new document from CBOR
 *
 * It will allocate a new document and set `document` pointer to it. It will
 * later need to be released with `::ditto_document_free`.
 *
 * The input `cbor` must be a valid CBOR.
 *
 * Return codes:
 *
 * * `0` -- success
 * * `1` -- invalid CBOR
 * * `2` -- cbor is not an object
 */
int ditto_document_new_cbor(const unsigned char *cbor_ptr,
                            uintptr_t cbor_len,
                            unsigned int site_id,
                            const struct Ditto_Document **document);

/**
 * Creates a new document from CBOR and a provided timestamp
 *
 * It will allocate a new document and set `document` pointer to it. It will
 * later need to be released with `::ditto_document_free`.
 *
 * The input `cbor` must be a valid CBOR.
 *
 * Return codes:
 *
 * * `0` -- success
 * * `1` -- invalid CBOR
 * * `2` -- cbor is not an object
 */
int ditto_document_new_cbor_with_timestamp(const unsigned char *cbor_ptr,
                                           uintptr_t cbor_len,
                                           unsigned int site_id,
                                           unsigned int timestamp,
                                           const struct Ditto_Document **document);

int ditto_document_pop_cbor(struct Ditto_Document *document,
                            const char *pointer,
                            const unsigned char **cbor_ptr,
                            uintptr_t *out_cbor_len);

int ditto_document_push_cbor(struct Ditto_Document *document,
                             const char *pointer,
                             const unsigned char *cbor_ptr,
                             uintptr_t cbor_len);

int ditto_document_remove(struct Ditto_Document *document, const char *pointer);

int ditto_document_replace_text(struct Ditto_Document *document,
                                const char *pointer,
                                uintptr_t index,
                                uintptr_t length,
                                const char *text);

int ditto_document_replace_with_counter(struct Ditto_Document *document, const char *pointer);

int ditto_document_replace_with_counter_with_timestamp(struct Ditto_Document *document,
                                                       const char *pointer,
                                                       unsigned int timestamp);

/**
 * Updates the document with values taken from provided CBOR data.
 *
 * Returns following error codes:
 *
 * * `0` -- no error
 * * `1` -- invalid CBOR data
 * * `2` -- CBOR data was not a map
 * * `3` -- update error
 *
 * In case of a non-zero return value, error message can be retrieved using
 * `::ditto_error_message` function.
 */
int ditto_document_update(struct Ditto_Document *document,
                          const unsigned char *cbor_ptr,
                          uintptr_t cbor_len,
                          bool create_path);

/**
 * Retrieves last thread-local error message (used by some synchronous APIs)
 * and removes it. Subsequent call to this function (if nothing else has
 * happened) will always return `NULL`.
 *
 * Returns `NULL` if there was no error. A non-null result MUST be freed using
 * `ditto_c_string_free`.
 */
char *ditto_error_message(void);

/**
 * Retrieves last thread-local error message (used by some synchronous APIs)
 * and retains ownership of it.
 *
 * Returns `NULL` if there was no error. A non-null result MUST NOT be freed
 * using `ditto_c_string_free`.
 */
const char *ditto_error_message_peek(void);

/**
 * Stop replication and all internal threads in the Ditto object.
 * The ditto object is freed by this function and must not be used again.
 */
void ditto_free(struct Ditto *ditto_raw);

unsigned int ditto_get_site_id(struct Ditto *ditto_raw);

/**
 * Listen address of ws_listen_transport. Must be called after
 * transport_go_online. The return value must be freed with
 * ditto_c_string_free().
 */
char *ditto_listen_local_addr(struct Ditto *ditto_raw, long long id);

int ditto_live_query(struct Ditto *ditto_raw,
                     const char *coll_name,
                     const Ditto_CompiledQuery *query,
                     const struct Ditto_OrderDefinition *order_by,
                     unsigned int order_by_len,
                     int limit,
                     unsigned int offset,
                     long long *id,
                     void *ctx,
                     void (*c_cb)(void *ctx, const struct Ditto_Document **documents, uintptr_t document_count, bool is_initial, const struct Ditto_Document **old_documents, uintptr_t old_document_count, uintptr_t *insertions, uintptr_t insertion_count, uintptr_t *deletions, uintptr_t deletion_count, uintptr_t *updates, uintptr_t update_count, uintptr_t *moves, uintptr_t move_count));

void ditto_live_query_stop(struct Ditto *ditto_raw, long long id);

void ditto_logger_init(bool debug);

/**
 * Make a Ditto object as an opaque pointer. The Ditto object creates the Tokio
 * runtime and starts internal threads. The return value is a raw pointer whose
 * only use is to supply as an argument to other ditto_* functions. The Ditto
 * object must be stopped and freed with ditto_free().
 */
struct Ditto *ditto_make_development(struct UninitializedDitto *uninit_ditto_raw,
                                     unsigned int site_id,
                                     const char *app_name);

/**
 * Make a Ditto object as an opaque pointer. The Ditto object creates the Tokio
 * runtime and starts internal threads. The return value is a raw pointer whose
 * only use is to supply as an argument to other ditto_* functions. The Ditto
 * object must be stopped and freed with ditto_free().
 */
struct Ditto *ditto_make_production(struct UninitializedDitto *uninit_ditto_raw,
                                    const char *certificate_config_str);

void ditto_mdns_platform_free(struct Arc_FfiMdnsPlatform *platform);

/**
 * Compiles string query into JMESPath query
 *
 * Return codes:
 *
 * * `QUERY_COMPILE_SUCCESS` -- success
 * * `QUERY_COMPILE_COMPILE_FAILED` -- invalid expression
 */
enum Ditto_QueryCompileResult ditto_query_compile(const char *expr, Ditto_CompiledQuery **query);

void ditto_query_filter_free(const struct Ditto_QueryFilter *query_filter);

int ditto_query_filter_next(const struct Ditto_QueryFilter *query_filter,
                            const struct Ditto_Document **document);

/**
 * Releases memory held by a compiled query
 */
void ditto_query_free(Ditto_CompiledQuery *query);

/**
 * Compiles JMESPath query
 *
 * Return codes:
 *
 * * `QUERY_COMPILE_SUCCESS` -- success
 * * `QUERY_COMPILE_COMPILE_FAILED` -- invalid expression
 */
enum Ditto_QueryCompileResult ditto_query_jmespath_compile(const char *expr,
                                                           Ditto_CompiledQuery **query);

/**
 * Compiles MongoDB-style query
 *
 * Return codes:
 *
 * * `QUERY_COMPILE_SUCCESS` -- success
 * * `QUERY_COMPILE_INVALIDINPUT` -- parsed value is not an object or JSON
 *   parsing failure
 * * `QUERY_COMPILE_COMPILEFAILED` -- transpilation error
 */
enum Ditto_QueryCompileResult ditto_query_mongo_compile(const char *json,
                                                        Ditto_CompiledQuery **query);

int ditto_read_transaction(struct Ditto *ditto_raw, const struct Ditto_ReadTransaction **txn);

void ditto_read_transaction_free(const struct Ditto_ReadTransaction *transaction);

int ditto_read_transaction_query(struct Ditto *ditto_raw,
                                 const char *coll_name,
                                 const struct Ditto_ReadTransaction *transaction,
                                 const Ditto_CompiledQuery *query,
                                 const struct Ditto_OrderDefinition *order_by,
                                 unsigned int order_by_len,
                                 int limit,
                                 unsigned int offset,
                                 const struct Ditto_QueryFilter **query_filter);

int ditto_read_transaction_query_filter(struct Ditto *ditto_raw,
                                        const char *coll_name,
                                        const struct Ditto_ReadTransaction *transaction,
                                        const Ditto_CompiledQuery *query,
                                        const struct Ditto_QueryFilter **query_filter);

struct Arc_FfiAwdlClientPlatform *ditto_register_awdl_client_platform(struct Ditto *ditto_raw,
                                                                      struct Arc_AwdlClientPlatformCallbacks *callbacks);

struct Arc_FfiAwdlServerPlatform *ditto_register_awdl_server_platform(struct Ditto *ditto_raw,
                                                                      struct Arc_AwdlServerPlatformCallbacks *callbacks);

struct Arc_FfiClientPlatform *ditto_register_ble_client_platform(struct Ditto *ditto_raw,
                                                                 struct Arc_ClientPlatformCallbacks *callbacks);

struct Arc_FfiServerPlatform *ditto_register_ble_server_platform(struct Ditto *ditto_raw,
                                                                 struct Arc_ServerPlatformCallbacks *callbacks);

struct Arc_FfiMdnsPlatform *ditto_register_mdns_platform(struct Ditto *ditto_raw,
                                                         struct Arc_MdnsPlatformCallbacks *callbacks);

/**
 * Register a function that will be called every time a transport changes
 * condition.
 *
 * This should drive UI indicators to indicate overall connectivity via methods
 * such as BLE, WiFi, or an internet-based server on a dedicated
 * WsConnectTransport.
 */
void ditto_register_transport_condition_changed_callback(struct Ditto *ditto_raw,
                                                         void *ctx,
                                                         void (*c_cb)(void*, long long, enum TransportCondition));

void ditto_remove_subscription(struct Ditto *ditto_raw, const char *collection, const char *query);

/**
 * Remove a transport.
 */
void ditto_remove_transport(struct Ditto *ditto_raw, long long id);

/**
 * Transport go offline.
 */
void ditto_transport_go_offline(struct Ditto *ditto_raw, long long id);

/**
 * Transport go online.
 */
void ditto_transport_go_online(struct Ditto *ditto_raw, long long id);

/**
 * Request bulk status information about the transports. Intended mostly for
 * statistical or debugging purposes.
 */
char *ditto_transports_diagnostics(struct Ditto *ditto_raw);

void ditto_vec_documents_free(const struct Ditto_Document **docs, uintptr_t doc_count);

void ditto_vec_usizes_free(uintptr_t *usizes, uintptr_t usize_count);

int ditto_write_transaction(struct Ditto *ditto_raw, const struct Ditto_WriteTransaction **txn);

int ditto_write_transaction_commit(const struct Ditto_WriteTransaction *transaction);

void ditto_write_transaction_free(const struct Ditto_WriteTransaction *transaction);

int ditto_write_transaction_query(struct Ditto *ditto_raw,
                                  const char *coll_name,
                                  const struct Ditto_WriteTransaction *transaction,
                                  const Ditto_CompiledQuery *query,
                                  const struct Ditto_OrderDefinition *order_by,
                                  unsigned int order_by_len,
                                  int limit,
                                  unsigned int offset,
                                  const struct Ditto_QueryFilter **query_filter);

int ditto_write_transaction_query_filter(struct Ditto *ditto_raw,
                                         const char *coll_name,
                                         const struct Ditto_WriteTransaction *transaction,
                                         const Ditto_CompiledQuery *query,
                                         const struct Ditto_QueryFilter **query_filter);

void ditto_write_transaction_rollback(const struct Ditto_WriteTransaction *transaction);

/**
 * The platform advises Rust that the status of publishing our service has
 * changed.
 */
void mdns_advertising_state_changed(struct Arc_FfiMdnsPlatform *platform,
                                    enum OnlineState state,
                                    enum TransportCondition result);

void mdns_platform_callbacks_free(struct Arc_MdnsPlatformCallbacks *mp);

struct Arc_MdnsPlatformCallbacks *mdns_platform_callbacks_new(void);

/**
 * The platform advises Rust that a peer has been identified and has
 * successfully resolved to a hostname and port.
 */
void mdns_platform_peer_appeared(struct Arc_FfiMdnsPlatform *mp,
                                 const char *service_name,
                                 const char *hostname,
                                 int port);

/**
 * The platform advises Rust that a peer's service has disappeared from mDNS.
 */
void mdns_platform_peer_disappeared(struct Arc_FfiMdnsPlatform *mp, const char *service_name);

/**
 * Register a function that Rust can call to start an mDNS responder on the
 * current device. It should include the service name string (in practice, the
 * announce string) and the TCP port that the Ditto TCP service is listening
 * on.
 */
void mdns_platform_register_start_advertising(struct Arc_MdnsPlatformCallbacks *mp,
                                              void *ctx,
                                              void (*c_cb)(void *ctx, const char *announce, const char *app_name, int service_port));

/**
 * Register a function that Rust can call to make the mDNS querier report Ditto
 * peers on an ongoing basis. This may be interrupted by events such as the
 * user backgrounding/foregrounding their app. Currently, this is not exposed
 * to Rust.
 */
void mdns_platform_register_start_searching(struct Arc_MdnsPlatformCallbacks *mp,
                                            void *ctx,
                                            void (*c_cb)(void *ctx));

/**
 * Register a function that Rust can call to stop the mDNS responder on the
 * current device.
 */
void mdns_platform_register_stop_advertising(struct Arc_MdnsPlatformCallbacks *mp,
                                             void *ctx,
                                             void (*c_cb)(void *ctx));

/**
 * Register a function that Rust can call to make the mDNS querier stop looking
 * for Ditto peers.
 */
void mdns_platform_register_stop_searching(struct Arc_MdnsPlatformCallbacks *mp,
                                           void *ctx,
                                           void (*c_cb)(void *ctx));

/**
 * The platform advises Rust that the status of searching for mDNS peers has
 * changed.
 */
void mdns_scanning_state_changed(struct Arc_FfiMdnsPlatform *platform,
                                 enum OnlineState state,
                                 enum TransportCondition result);

/**
 * Check the store for an existing cached site ID. Returns 0 if there no
 * existing site ID could be fetched.
 */
unsigned int uninitialized_ditto_get_site_id(struct UninitializedDitto *uninit_ditto_raw);

/**
 * Make an UninitializedDitto object as an opaque pointer. This object serves
 * as an intermediate object that allows database access. This allows the SDK
 * to check if a pre-existing site ID has been persisted.
 */
struct UninitializedDitto *uninitialized_ditto_make(const char *working_dir, uintptr_t mapsize);

/**
 * verify a base64 encoded license string
 *
 * returns:
 * - 0 if signature is valid
 * - -1 if signature is invalid
 * - -2 if the license is expired
 * - -3 if the base64 license string was not decodable by base64 crate
 * - -4 if anything else failed
 */
int verify_license(const char *license_str);

#endif
/** \file dittoffi.h */

